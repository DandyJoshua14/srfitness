{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/generate-voice-response-flow.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview A voice agent flow that responds to user queries and can navigate the site.\n *\n * - generateVoiceResponse - A function that handles the voice agent's response generation.\n * - VoiceAgentInput - The input type for the voice agent.\n * - VoiceAgentOutput - The return type for the voice agent, now including an optional navigation path.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\n\nconst VoiceAgentInputSchema = z.object({\n  query: z.string().describe(\"The user's spoken query, transcribed to text.\"),\n});\nexport type VoiceAgentInput = z.infer<typeof VoiceAgentInputSchema>;\n\nconst VoiceAgentOutputSchema = z.object({\n  response: z.string().describe(\"The AI's text response to be spoken back to the user.\"),\n  navigationPath: z.string().nullable().optional().describe(\"An optional path to navigate to on the website (e.g., '/awards', '/meal-planner'). Should be null or omitted if no navigation is required.\"),\n});\nexport type VoiceAgentOutput = z.infer<typeof VoiceAgentOutputSchema>;\n\n// Define valid navigation paths\nconst validPaths = [\n    '/', '/personal-training', '/burn-off-bootcamp', '/awards', \n    '/lifestyle-magazine', '/public-speaking', '/equipment-services', '/#contact',\n    '/meal-planner', '/Smart Scan', '/global-connect', '/community', '/profile', \n    '/privacy-policy', '/terms-of-service', '/corporate-wellness', '/marketplace'\n] as const;\n\n// Define the navigation tool\nconst navigateToPage = ai.defineTool(\n    {\n      name: 'navigateToPage',\n      description: 'Use this tool to navigate the user to a specific page on the SR Fitness website when they ask to go somewhere. Use it for requests like \"go to\", \"take me to\", \"open\", \"show me\", etc.',\n      inputSchema: z.object({\n        path: z.enum(validPaths).describe(\"The page path to navigate to.\"),\n        pageName: z.string().describe(\"The friendly name of the page for confirmation message, e.g., 'the awards page', 'your profile'.\")\n      }),\n      outputSchema: z.string(),\n    },\n    async ({ path }) => `Navigating to ${path}`\n);\n\n\nexport async function generateVoiceResponse(input: VoiceAgentInput): Promise<VoiceAgentOutput> {\n  return generateVoiceResponseFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'voiceAgentPrompt',\n  input: { schema: VoiceAgentInputSchema },\n  output: { schema: VoiceAgentOutputSchema },\n  tools: [navigateToPage],\n  prompt: `You are Ninna, a friendly and helpful voice assistant for the SR Fitness application.\nYour role is to answer user questions about fitness, nutrition, our services, or general inquiries.\nIf the user asks to navigate to a page (e.g., \"go to\", \"open\", \"show me\"), you MUST use the navigateToPage tool.\nIf you are not navigating, provide a helpful text response and ensure the navigationPath is null.\nBe conversational, encouraging, and keep your answers concise and clear, as they will be spoken aloud.\nIf you don't know an answer, say so politely.\n\nUser query: {{{query}}}\n  `,\n});\n\nconst generateVoiceResponseFlow = ai.defineFlow(\n  {\n    name: 'generateVoiceResponseFlow',\n    inputSchema: VoiceAgentInputSchema,\n    outputSchema: VoiceAgentOutputSchema,\n  },\n  async (input) => {\n    const response = await prompt(input);\n\n    // 1. Check for tool calls first\n    const toolCalls = response.toolCalls;\n    if (toolCalls && toolCalls.length > 0) {\n        const navigateCall = toolCalls.find(call => call.tool === 'navigateToPage');\n        if (navigateCall) {\n            const { path, pageName } = navigateCall.input as { path: string; pageName: string };\n            return {\n                response: `Of course, taking you to ${pageName} now.`,\n                navigationPath: path,\n            };\n        }\n    }\n    \n    // 2. If no tool call, check for structured output\n    const output = response.output;\n    if (output) {\n      return {\n          response: output.response,\n          navigationPath: output.navigationPath || null\n      };\n    }\n\n    // 3. If no structured output, check for a simple text response as a fallback\n    const text = response.text;\n    if (text) {\n        return {\n            response: text,\n            navigationPath: null\n        };\n    }\n\n    // 4. Fallback if we have neither tool calls, structured output, nor text\n    return { response: \"I'm sorry, I had a problem thinking of a response. Please try again.\", navigationPath: null };\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,wBAAwB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACrC,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC7B;AAGA,MAAM,yBAAyB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACtC,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC9B,gBAAgB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC;AAC5D;AAGA,gCAAgC;AAChC,MAAM,aAAa;IACf;IAAK;IAAsB;IAAsB;IACjD;IAAuB;IAAoB;IAAuB;IAClE;IAAiB;IAAe;IAAmB;IAAc;IACjE;IAAmB;IAAqB;IAAuB;CAClE;AAED,6BAA6B;AAC7B,MAAM,iBAAiB,mHAAA,CAAA,KAAE,CAAC,UAAU,CAChC;IACE,MAAM;IACN,aAAa;IACb,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACpB,MAAM,uIAAA,CAAA,IAAC,CAAC,IAAI,CAAC,YAAY,QAAQ,CAAC;QAClC,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAChC;IACA,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM;AACxB,GACA,OAAO,EAAE,IAAI,EAAE,GAAK,CAAC,cAAc,EAAE,MAAM;AAIxC,eAAe,sBAAsB,KAAsB;IAChE,OAAO,0BAA0B;AACnC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAE,QAAQ;IAAsB;IACvC,QAAQ;QAAE,QAAQ;IAAuB;IACzC,OAAO;QAAC;KAAe;IACvB,QAAQ,CAAC;;;;;;;;EAQT,CAAC;AACH;AAEA,MAAM,4BAA4B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC7C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,MAAM,WAAW,MAAM,OAAO;IAE9B,gCAAgC;IAChC,MAAM,YAAY,SAAS,SAAS;IACpC,IAAI,aAAa,UAAU,MAAM,GAAG,GAAG;QACnC,MAAM,eAAe,UAAU,IAAI,CAAC,CAAA,OAAQ,KAAK,IAAI,KAAK;QAC1D,IAAI,cAAc;YACd,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,aAAa,KAAK;YAC7C,OAAO;gBACH,UAAU,CAAC,yBAAyB,EAAE,SAAS,KAAK,CAAC;gBACrD,gBAAgB;YACpB;QACJ;IACJ;IAEA,kDAAkD;IAClD,MAAM,SAAS,SAAS,MAAM;IAC9B,IAAI,QAAQ;QACV,OAAO;YACH,UAAU,OAAO,QAAQ;YACzB,gBAAgB,OAAO,cAAc,IAAI;QAC7C;IACF;IAEA,6EAA6E;IAC7E,MAAM,OAAO,SAAS,IAAI;IAC1B,IAAI,MAAM;QACN,OAAO;YACH,UAAU;YACV,gBAAgB;QACpB;IACJ;IAEA,yEAAyE;IACzE,OAAO;QAAE,UAAU;QAAwE,gBAAgB;IAAK;AAClH;;;IA9DoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 391, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/generate-speech-audio-flow.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview Converts text to speech audio.\n *\n * - generateSpeechAudio - Converts text into a WAV audio data URI.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\nimport wav from 'wav';\nimport { googleAI } from '@genkit-ai/googleai';\n\n// This is the exported function React components will call.\nexport async function generateSpeechAudio(text: string): Promise<string> {\n  return generateSpeechAudioFlow(text);\n}\n\nconst generateSpeechAudioFlow = ai.defineFlow(\n  {\n    name: 'generateSpeechAudioFlow',\n    inputSchema: z.string(),\n    outputSchema: z.string(), // data URI\n  },\n  async (text) => {\n    if (!text.trim()) {\n      return '';\n    }\n\n    const { media } = await ai.generate({\n      model: googleAI.model('gemini-2.5-flash-preview-tts'),\n      config: {\n        responseModalities: ['AUDIO'],\n        speechConfig: {\n          voiceConfig: {\n            prebuiltVoiceConfig: { voiceName: 'Umbriel' }, // Updated to a valid female-sounding voice\n          },\n        },\n      },\n      prompt: text,\n    });\n\n    if (!media) {\n      throw new Error('No audio media was returned from the TTS model.');\n    }\n\n    // The media URL is a data URI with raw PCM data\n    // Format: 'data:audio/L16;rate=24000;channels=1;base64,....'\n    const audioBuffer = Buffer.from(\n      media.url.substring(media.url.indexOf(',') + 1),\n      'base64'\n    );\n    \n    const wavDataUri = await toWavDataUri(audioBuffer);\n    return wavDataUri;\n  }\n);\n\n// Helper function to convert raw PCM audio buffer to a WAV data URI\nasync function toWavDataUri(\n  pcmData: Buffer,\n  channels = 1,\n  rate = 24000,\n  sampleWidth = 2\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const writer = new wav.Writer({\n      channels,\n      sampleRate: rate,\n      bitDepth: sampleWidth * 8,\n    });\n\n    const buffers: Buffer[] = [];\n    writer.on('data', (chunk) => {\n      buffers.push(chunk);\n    });\n    writer.on('end', () => {\n      const wavBuffer = Buffer.concat(buffers);\n      resolve(`data:audio/wav;base64,${wavBuffer.toString('base64')}`);\n    });\n    writer.on('error', reject);\n\n    writer.write(pcmData);\n    writer.end();\n  });\n}\n"],"names":[],"mappings":";;;;;AAEA;;;;CAIC,GAED;AACA;AAAA;AACA;AACA;AAAA;;;;;;;;AAGO,eAAe,oBAAoB,IAAY;IACpD,OAAO,wBAAwB;AACjC;AAEA,MAAM,0BAA0B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC3C;IACE,MAAM;IACN,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM;IACrB,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM;AACxB,GACA,OAAO;IACL,IAAI,CAAC,KAAK,IAAI,IAAI;QAChB,OAAO;IACT;IAEA,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,mHAAA,CAAA,KAAE,CAAC,QAAQ,CAAC;QAClC,OAAO,2KAAA,CAAA,WAAQ,CAAC,KAAK,CAAC;QACtB,QAAQ;YACN,oBAAoB;gBAAC;aAAQ;YAC7B,cAAc;gBACZ,aAAa;oBACX,qBAAqB;wBAAE,WAAW;oBAAU;gBAC9C;YACF;QACF;QACA,QAAQ;IACV;IAEA,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IAEA,gDAAgD;IAChD,6DAA6D;IAC7D,MAAM,cAAc,OAAO,IAAI,CAC7B,MAAM,GAAG,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,OAAO,CAAC,OAAO,IAC7C;IAGF,MAAM,aAAa,MAAM,aAAa;IACtC,OAAO;AACT;AAGF,oEAAoE;AACpE,eAAe,aACb,OAAe,EACf,WAAW,CAAC,EACZ,OAAO,KAAK,EACZ,cAAc,CAAC;IAEf,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,MAAM,SAAS,IAAI,4HAAA,CAAA,UAAG,CAAC,MAAM,CAAC;YAC5B;YACA,YAAY;YACZ,UAAU,cAAc;QAC1B;QAEA,MAAM,UAAoB,EAAE;QAC5B,OAAO,EAAE,CAAC,QAAQ,CAAC;YACjB,QAAQ,IAAI,CAAC;QACf;QACA,OAAO,EAAE,CAAC,OAAO;YACf,MAAM,YAAY,OAAO,MAAM,CAAC;YAChC,QAAQ,CAAC,sBAAsB,EAAE,UAAU,QAAQ,CAAC,WAAW;QACjE;QACA,OAAO,EAAE,CAAC,SAAS;QAEnB,OAAO,KAAK,CAAC;QACb,OAAO,GAAG;IACZ;AACF;;;IAvEsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 481, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/firebase/config.ts"],"sourcesContent":["\nimport { initializeApp, getApps, getApp } from 'firebase/app';\nimport { getFirestore } from 'firebase/firestore';\n\n// Your web app's Firebase configuration\n// IMPORTANT: Do not remove or modify this object.\nconst firebaseConfig = {\n  projectId: \"sr-fitness-idcxl\",\n  appId: \"1:208349550507:web:a0e1f3f994e7134581a4ee\",\n  storageBucket: \"sr-fitness-idcxl.firebasestorage.app\",\n  apiKey: \"AIzaSyBtNrQdRpSWVBeQSwZGszZoaX-HaQm9ne4\",\n  authDomain: \"sr-fitness-idcxl.firebaseapp.com\",\n  measurementId: \"G-ZSHZD6ZLPY\",\n  messagingSenderId: \"208349550507\"\n};\n\n// Initialize Firebase\nconst app = getApps().length ? getApp() : initializeApp(firebaseConfig);\nconst db = getFirestore(app);\n\nexport { app, db };\n"],"names":[],"mappings":";;;;AACA;AAAA;AACA;AAAA;;;AAEA,wCAAwC;AACxC,kDAAkD;AAClD,MAAM,iBAAiB;IACrB,WAAW;IACX,OAAO;IACP,eAAe;IACf,QAAQ;IACR,YAAY;IACZ,eAAe;IACf,mBAAmB;AACrB;AAEA,sBAAsB;AACtB,MAAM,MAAM,CAAA,GAAA,oLAAA,CAAA,UAAO,AAAD,IAAI,MAAM,GAAG,CAAA,GAAA,oLAAA,CAAA,SAAM,AAAD,MAAM,CAAA,GAAA,oLAAA,CAAA,gBAAa,AAAD,EAAE;AACxD,MAAM,KAAK,CAAA,GAAA,iKAAA,CAAA,eAAY,AAAD,EAAE","debugId":null}},
    {"offset": {"line": 512, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/services/firestore.ts"],"sourcesContent":["\nimport { db } from '@/lib/firebase/config';\nimport { collection, addDoc, getDocs, deleteDoc, doc, query, orderBy, serverTimestamp, getDoc } from 'firebase/firestore';\n\n// --------- Blog Post Types and Functions ---------\n\ninterface Post {\n  id?: string;\n  author: { name: string; avatar: string; dataAiHint: string; };\n  timestamp: any; // Firestore timestamp\n  title: string;\n  content: string;\n  image: string;\n  dataAiHint: string;\n  likes: number;\n  comments: number;\n  isAnnouncement: boolean;\n  category: string;\n}\n\nconst postsCollectionRef = collection(db, 'blogPosts');\n\nexport const addPost = async (postData: Omit<Post, 'id' | 'timestamp'>) => {\n  try {\n    await addDoc(postsCollectionRef, {\n      ...postData,\n      timestamp: serverTimestamp(),\n    });\n  } catch (error) {\n    console.error(\"Error adding document: \", error);\n    throw new Error(\"Could not add post to Firestore.\");\n  }\n};\n\nexport const getPosts = async (): Promise<Post[]> => {\n  try {\n    const q = query(postsCollectionRef, orderBy('timestamp', 'desc'));\n    const querySnapshot = await getDocs(q);\n    return querySnapshot.docs.map(doc => {\n        const data = doc.data();\n        return {\n            id: doc.id,\n            ...data,\n            timestamp: data.timestamp?.toDate().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) || new Date().toLocaleDateString(),\n        } as Post;\n    });\n  } catch (error) {\n    console.error(\"Error getting documents: \", error);\n    throw new Error(\"Could not fetch posts from Firestore.\");\n  }\n};\n\nexport const deletePost = async (postId: string) => {\n  try {\n    await deleteDoc(doc(db, 'blogPosts', postId));\n  } catch (error) {\n    console.error(\"Error deleting document: \", error);\n    throw new Error(\"Could not delete post from Firestore.\");\n  }\n};\n\n\n// --------- Product Types and Functions ---------\n\nexport interface Product {\n    id?: string;\n    name: string;\n    category: string;\n    price: number;\n    image: string;\n    dataAiHint: string;\n    rating: number;\n    isNew: boolean;\n    timestamp: any;\n}\n\nconst productsCollectionRef = collection(db, 'products');\n\nexport const addProduct = async (productData: Omit<Product, 'id' | 'timestamp'>) => {\n    try {\n        await addDoc(productsCollectionRef, {\n            ...productData,\n            timestamp: serverTimestamp(),\n        });\n    } catch (error) {\n        console.error(\"Error adding product: \", error);\n        throw new Error(\"Could not add product to Firestore.\");\n    }\n};\n\nexport const getProducts = async (): Promise<Product[]> => {\n    try {\n        const q = query(productsCollectionRef, orderBy('timestamp', 'desc'));\n        const querySnapshot = await getDocs(q);\n        return querySnapshot.docs.map(doc => ({\n            id: doc.id,\n            ...doc.data(),\n        } as Product));\n    } catch (error) {\n        console.error(\"Error getting products: \", error);\n        throw new Error(\"Could not fetch products from Firestore.\");\n    }\n};\n\nexport const deleteProduct = async (productId: string) => {\n    try {\n        await deleteDoc(doc(db, 'products', productId));\n    } catch (error) {\n        console.error(\"Error deleting product: \", error);\n        throw new Error(\"Could not delete product from Firestore.\");\n    }\n};\n\n\n// --------- Magazine Article Types and Functions ---------\n\nexport interface Article {\n  id?: string;\n  title: string;\n  category: string;\n  image: string;\n  dataAiHint: string;\n  excerpt: string;\n  timestamp: any;\n}\n\nconst articlesCollectionRef = collection(db, 'magazineArticles');\n\nexport const addArticle = async (articleData: Omit<Article, 'id' | 'timestamp'>) => {\n  try {\n    await addDoc(articlesCollectionRef, {\n        ...articleData,\n        timestamp: serverTimestamp()\n    });\n  } catch (error) {\n    console.error(\"Error adding article: \", error);\n    throw new Error(\"Could not add article to Firestore.\");\n  }\n};\n\nexport const getArticles = async (): Promise<Article[]> => {\n  try {\n    const q = query(articlesCollectionRef, orderBy('timestamp', 'desc'));\n    const querySnapshot = await getDocs(q);\n    return querySnapshot.docs.map(doc => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        ...data,\n        timestamp: data.timestamp?.toDate().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) || new Date().toLocaleDateString(),\n      } as Article;\n    });\n  } catch (error) {\n    console.error(\"Error getting articles: \", error);\n    throw new Error(\"Could not fetch articles from Firestore.\");\n  }\n};\n\nexport const deleteArticle = async (articleId: string) => {\n  try {\n    await deleteDoc(doc(db, 'magazineArticles', articleId));\n  } catch (error) {\n    console.error(\"Error deleting article: \", error);\n    throw new Error(\"Could not delete article from Firestore.\");\n  }\n};\n\n\n// --------- Vote Types and Functions ---------\n\nexport interface Vote {\n    id?: string;\n    contestantId: string;\n    contestantName: string;\n    contestantCategory: string;\n    numberOfVotes: number;\n    timestamp: any;\n}\n\nconst votesCollectionRef = collection(db, 'votes');\n\nexport const addVote = async (voteData: Omit<Vote, 'id' | 'timestamp'>) => {\n    try {\n        await addDoc(votesCollectionRef, {\n            ...voteData,\n            timestamp: serverTimestamp(),\n        });\n    } catch (error) {\n        console.error(\"Error adding vote: \", error);\n        throw new Error(\"Could not add vote to Firestore.\");\n    }\n};\n\nexport const getVotes = async (): Promise<Vote[]> => {\n    try {\n        const q = query(votesCollectionRef, orderBy('timestamp', 'desc'));\n        const querySnapshot = await getDocs(q);\n        return querySnapshot.docs.map(doc => {\n          const data = doc.data();\n          return {\n            id: doc.id,\n            ...data,\n            timestamp: data.timestamp?.toDate().toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) || 'N/A',\n          } as Vote\n        });\n    } catch (error) {\n        console.error(\"Error getting votes: \", error);\n        throw new Error(\"Could not fetch votes from Firestore.\");\n    }\n};\n\n// --------- Nomination Types and Functions ---------\n\nexport interface Nomination {\n  id?: string;\n  category: string;\n  nomineeName: string;\n  nomineePhone: string;\n  nominationReason: string;\n  nominatorName: string;\n  nominatorPhone: string;\n  timestamp: any;\n}\n\nconst nominationsCollectionRef = collection(db, 'nominations');\n\nexport const addNomination = async (nominationData: Omit<Nomination, 'id' | 'timestamp'>) => {\n    try {\n        await addDoc(nominationsCollectionRef, {\n            ...nominationData,\n            timestamp: serverTimestamp(),\n        });\n    } catch (error) {\n        console.error(\"Error adding nomination: \", error);\n        throw new Error(\"Could not add nomination to Firestore.\");\n    }\n};\n\nexport const getNominations = async (): Promise<Nomination[]> => {\n    try {\n        const q = query(nominationsCollectionRef, orderBy('timestamp', 'desc'));\n        const querySnapshot = await getDocs(q);\n        return querySnapshot.docs.map(doc => {\n            const data = doc.data();\n            return {\n                id: doc.id,\n                ...data,\n                timestamp: data.timestamp?.toDate().toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' }) || 'N/A',\n            } as Nomination;\n        });\n    } catch (error) {\n        console.error(\"Error getting nominations: \", error);\n        throw new Error(\"Could not fetch nominations from Firestore.\");\n    }\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 725, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n'use server';\n\nimport { z } from 'zod';\nimport { addNomination } from '@/services/firestore';\nimport { Resend } from 'resend';\nimport { redirect } from 'next/navigation';\n\n// Explicitly read environment variables at the top level\nconst NEXT_PUBLIC_BASE_URL = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:9002';\nconst RESEND_API_KEY = process.env.RESEND_API_KEY;\nconst PAYSTACK_SECRET_KEY = process.env.PAYSTACK_SECRET_KEY;\n// We will read the Zapier URL inside the function to ensure it's not missed.\n\nconst nominationFormSchema = z.object({\n  category: z.string(),\n  nomineeName: z.string(),\n  nomineePhone: z.string(),\n  nominationReason: z.string(),\n  nominatorName: z.string(),\n  nominatorPhone: z.string(),\n});\n\nconst voteSchema = z.object({\n  contestantId: z.string(),\n  contestantName: z.string(),\n  contestantCategory: z.string(),\n  numberOfVotes: z.number().int().positive(),\n});\n\nconst remitaPaymentRequestSchema = z.object({\n  amount: z.number(),\n  charge: z.number(),\n  transactionReference: z.string(),\n  customerEmail: z.string().email(),\n  customerName: z.string(),\n  customerPhoneNumber: z.string(),\n  description: z.string(),\n  // Pass along vote data for recording\n  contestantId: z.string(),\n  contestantName: z.string(),\n  contestantCategory: z.string(),\n  numberOfVotes: z.number(),\n});\n\nconst remitaReceiptSchema = z.object({\n  rrr: z.string(),\n});\n\nconst remitaRrrValidationSchema = z.object({\n  rrr: z.string(),\n  channelId: z.string(),\n});\n\nconst paystackPaymentRequestSchema = z.object({\n  email: z.string().email(),\n  amount: z.number(),\n  metadata: z.object({\n    contestantId: z.string(),\n    contestantName: z.string(),\n    contestantCategory: z.string(),\n    numberOfVotes: z.number(),\n  }),\n});\n\n\nexport async function sendNominationEmail(formData: z.infer<typeof nominationFormSchema>) {\n  const validatedFields = nominationFormSchema.safeParse(formData);\n\n  if (!validatedFields.success) {\n    return { success: false, error: 'Invalid form data.' };\n  }\n  \n  try {\n    const { category, nomineeName, nomineePhone, nominationReason, nominatorName, nominatorPhone } = validatedFields.data;\n\n    // 1. Attempt to send email\n    if (RESEND_API_KEY) {\n      const resend = new Resend(RESEND_API_KEY);\n      const { data, error } = await resend.emails.send({\n        from: 'SR Fitness Awards <noreply@srfitness.com.ng>',\n        to: ['sampson07@outlook.com', 'srfitness247@gmail.com'],\n        subject: 'New Award Nomination Received!',\n        html: `\n          <h1>New SR Fitness Award Nomination</h1>\n          <p>A new nomination has been submitted. Here are the details:</p>\n          <h2>Nominee Details:</h2>\n          <ul>\n            <li><strong>Category:</strong> ${category}</li>\n            <li><strong>Name:</strong> ${nomineeName}</li>\n            <li><strong>Phone:</strong> ${nomineePhone}</li>\n          </ul>\n          <h2>Reason for Nomination:</h2>\n          <p>${nominationReason}</p>\n          <hr />\n          <h2>Nominator Details:</h2>\n          <ul>\n            <li><strong>Name:</strong> ${nominatorName}</li>\n            <li><strong>Phone:</strong> ${nominatorPhone}</li>\n          </ul>\n        `,\n      });\n\n      if (error) {\n        // If email fails, return an error and do not save to DB\n        console.error('Resend API Error:', error);\n        return { success: false, error: 'Failed to send nomination email. Please try again.' };\n      }\n    } else {\n        console.warn('Resend API key is not configured. Skipping email sending.');\n    }\n\n    // 2. If email is sent (or skipped), save to Firestore\n    await addNomination(validatedFields.data);\n    \n    return { success: true, message: 'Nomination submitted successfully!' };\n\n  } catch (error) {\n    console.error('An unexpected error occurred in sendNominationEmail:', error);\n    return {\n      success: false,\n      error: 'An unexpected server error occurred. Please try again later.',\n    };\n  }\n}\n\n/**\n * Sends vote data to a Zapier webhook. This is the primary action after a\n * payment is successfully verified.\n */\nexport async function recordVote(voteData: z.infer<typeof voteSchema>) {\n  const validatedFields = voteSchema.safeParse(voteData);\n\n  if (!validatedFields.success) {\n    console.error(\"Invalid vote data for Zapier:\", validatedFields.error);\n    return {\n      success: false,\n      error: 'Invalid vote data provided.',\n    };\n  }\n\n  // Read the Zapier webhook URL from environment variables *inside* the function.\n  // This ensures the most current value is used every time the function is called.\n  const zapierWebhookUrl = process.env.ZAPIER_VOTE_WEBHOOK_URL;\n  \n  if (!zapierWebhookUrl) {\n    console.error(\"ZAPIER_VOTE_WEBHOOK_URL is not set. Cannot send vote data.\");\n    // Since Zapier is the only destination, this is now a critical failure.\n    return {\n      success: false,\n      error: 'Integration endpoint is not configured. Please contact support.',\n    };\n  }\n\n  try {\n    const response = await fetch(zapierWebhookUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        ...validatedFields.data,\n        timestamp: new Date().toISOString(),\n      }),\n    });\n\n    if (response.ok) {\n        console.log(\"Successfully sent vote data to Zapier.\");\n        return { success: true, message: \"Vote successfully recorded.\" };\n    } else {\n        const responseBody = await response.text();\n        console.error(`Zapier webhook call failed with status ${response.status}: ${responseBody}`);\n        return {\n          success: false,\n          error: 'Failed to send vote data to the tracking system.',\n        };\n    }\n  } catch (error) {\n    console.error(\"Failed to trigger Zapier webhook due to a network or fetch error:\", error);\n    return {\n      success: false,\n      error: 'Could not connect to the vote tracking system.',\n    };\n  }\n}\n\nexport async function createPaystackPayment(paymentData: z.infer<typeof paystackPaymentRequestSchema>) {\n    const validatedFields = paystackPaymentRequestSchema.safeParse(paymentData);\n    if (!validatedFields.success) {\n        return { success: false, error: 'Invalid payment data provided.' };\n    }\n\n    if (!PAYSTACK_SECRET_KEY) {\n        console.error(\"Paystack secret key is not configured.\");\n        return { success: false, error: \"Payment gateway is not configured correctly.\" };\n    }\n\n    const { email, amount, metadata } = validatedFields.data;\n    \n    // Ensure the callback URL is correctly formed.\n    const callbackUrl = `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:9002'}/vote/callback`;\n\n\n    const body = {\n        email,\n        amount: amount * 100, // Paystack expects amount in kobo\n        callback_url: callbackUrl,\n        metadata,\n    };\n\n    try {\n        const response = await fetch('https://api.paystack.co/transaction/initialize', {\n            method: 'POST',\n            body: JSON.stringify(body),\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${PAYSTACK_SECRET_KEY}`,\n            }\n        });\n        \n        const data = await response.json();\n        \n        if (data.status) {\n            return {\n                success: true,\n                authorizationUrl: data.data.authorization_url,\n            };\n        } else {\n            console.error(\"Paystack API error:\", data.message);\n            return { success: false, error: data.message || 'Payment initiation failed.' };\n        }\n\n    } catch (error) {\n        console.error(\"Error calling Paystack API:\", error);\n        return { success: false, error: \"Could not connect to the payment gateway.\" };\n    }\n}\n\nexport async function verifyPaystackPayment(reference: string) {\n    if (!reference) {\n        return { success: false, error: 'No payment reference provided.', status: 'error' };\n    }\n\n    if (!PAYSTACK_SECRET_KEY) {\n        console.error(\"Paystack secret key is not configured.\");\n        return { success: false, error: \"Payment gateway is not configured correctly.\", status: 'error' };\n    }\n\n    try {\n        const response = await fetch(`https://api.paystack.co/transaction/verify/${reference}`, {\n            method: 'GET',\n            headers: {\n                'Authorization': `Bearer ${PAYSTACK_SECRET_KEY}`,\n            }\n        });\n\n        const data = await response.json();\n\n        if (data.status && data.data.status === 'success') {\n            const { contestantId, contestantName, contestantCategory, numberOfVotes } = data.data.metadata;\n            \n            // This is the crucial step: record the vote only after successful verification.\n            const voteRecordResult = await recordVote({\n                contestantId,\n                contestantName,\n                contestantCategory,\n                numberOfVotes: Number(numberOfVotes),\n            });\n\n            if (voteRecordResult.success) {\n                return { \n                    success: true, \n                    message: 'Payment verified and vote recorded successfully!',\n                    status: 'success',\n                };\n            } else {\n                 return { \n                    success: false, \n                    error: `Payment was successful, but vote recording failed. Please contact support. Error: ${voteRecordResult.error}`,\n                    status: 'error',\n                };\n            }\n            \n        } else {\n            return { \n                success: false, \n                error: `Payment verification failed: ${data.data.gateway_response}`,\n                status: data.data.status || 'failed',\n            };\n        }\n\n    } catch (error) {\n        console.error(\"Error verifying Paystack payment:\", error);\n        return { success: false, error: \"Could not connect to the payment gateway for verification.\", status: 'error' };\n    }\n}\n\n\nexport async function createRemitaPayment(paymentData: z.infer<typeof remitaPaymentRequestSchema>) {\n    const validatedFields = remitaPaymentRequestSchema.safeParse(paymentData);\n    if (!validatedFields.success) {\n        return { success: false, error: \"Invalid Remita payment data.\" };\n    }\n\n    // Remita API key is missing. Assuming it's also a subscription key, similar to the Wema one that was removed.\n    const REMITA_SUBSCRIPTION_KEY = process.env.REMITA_SUBSCRIPTION_KEY;\n    if (!REMITA_SUBSCRIPTION_KEY) {\n      console.error(\"Remita subscription key is not set.\");\n      return { success: false, error: \"Payment gateway is not configured correctly.\" };\n    }\n\n\n    const { amount, charge, transactionReference, customerEmail, customerName, customerPhoneNumber, description, contestantId, contestantName, contestantCategory, numberOfVotes } = validatedFields.data;\n\n    const body = {\n        // ... (Remita API specific body, placeholders for simplicity)\n        channelId: \"string\", \n        cif: \"string\", \n        customerAccount: \"string\", \n        amount: amount,\n        charge: charge,\n        transactionReference: transactionReference,\n        customerEmail: customerEmail,\n        customerPhoneNumber: customerPhoneNumber,\n        customerName: customerName,\n        rrr: \"string\", \n        payerEmail: customerEmail,\n        payerName: customerName,\n        payerNumber: customerPhoneNumber,\n        description: description,\n        billAuthOptions: {\n            pin: \"string\",\n            otp: \"string\",\n            biometricPolicy: \"string\",\n            biometricToken: \"string\",\n            platformTransactionReference: \"string\",\n            authenticationType: 0\n        }\n    };\n\n    try {\n        const response = await fetch('https://wema-alatdev-apimgt.azure-api.net/remita-payments/api/RemitaPayment/PayRemitaBill', {\n            method: 'POST',\n            body: JSON.stringify(body),\n            headers: {\n                'Content-Type': 'application/json',\n                'Cache-Control': 'no-cache',\n                'Ocp-Apim-Subscription-Key': REMITA_SUBSCRIPTION_KEY,\n            }\n        });\n\n        const responseText = await response.text();\n        console.log(\"Remita PayRemitaBill response status:\", response.status);\n        console.log(\"Remita PayRemitaBill response body:\", responseText);\n        \n        if (response.ok) {\n            const voteData = { contestantId, contestantName, contestantCategory, numberOfVotes };\n            const voteRecordResult = await recordVote(voteData);\n            if (voteRecordResult.success) {\n                return { success: true, message: \"Remita payment processed and vote recorded successfully.\", data: JSON.parse(responseText) };\n            } else {\n                return { success: false, error: `Remita payment succeeded, but vote recording failed: ${voteRecordResult.error}` };\n            }\n        } else {\n             if (response.status === 500) {\n                 return { success: false, error: `Remita payment failed due to an internal server error on the gateway. Please try again later or contact support.` };\n             }\n            return { success: false, error: `Remita payment failed: ${responseText}` };\n        }\n\n    } catch(error) {\n        console.error(\"Error calling Remita PayRemitaBill API:\", error);\n        return { success: false, error: \"Could not connect to the Remita payment gateway.\" };\n    }\n}\n\nexport async function printRemitaReceipt(receiptData: z.infer<typeof remitaReceiptSchema>) {\n    const validatedFields = remitaReceiptSchema.safeParse(receiptData);\n    if (!validatedFields.success) {\n        return { success: false, error: \"Invalid Remita receipt data.\" };\n    }\n    \n    // Remita API key is missing. Assuming it's also a subscription key.\n    const REMITA_SUBSCRIPTION_KEY = process.env.REMITA_SUBSCRIPTION_KEY;\n    if (!REMITA_SUBSCRIPTION_KEY) {\n      console.error(\"Remita subscription key is not set.\");\n      return { success: false, error: \"Payment gateway is not configured correctly.\" };\n    }\n\n    const { rrr } = validatedFields.data;\n\n    const remitaUrl = `https://wema-alatdev-apimgt.azure-api.net/remita-payments/api/RemitaPayment/PrintRemitaReceipt/${rrr}`;\n\n    try {\n        const response = await fetch(remitaUrl, {\n            method: 'GET',\n            headers: {\n                'Cache-Control': 'no-cache',\n                'Ocp-Apim-Subscription-Key': REMITA_SUBSCRIPTION_KEY,\n            }\n        });\n\n        const responseText = await response.text();\n        console.log(\"Remita PrintRemitaReceipt response status:\", response.status);\n        console.log(\"Remita PrintRemitaReceipt response body:\", responseText);\n        \n        if (response.ok) {\n            return { success: true, receiptData: responseText };\n        } else {\n            return { success: false, error: `Failed to fetch Remita receipt: ${responseText}` };\n        }\n\n    } catch(error) {\n        console.error(\"Error calling Remita PrintRemitaReceipt API:\", error);\n        return { success: false, error: \"Could not connect to the Remita payment gateway to print receipt.\" };\n    }\n}\n\n\nexport async function validateRemitaRrr(validationData: z.infer<typeof remitaRrrValidationSchema>) {\n    const validatedFields = remitaRrrValidationSchema.safeParse(validationData);\n    if (!validatedFields.success) {\n        return { success: false, error: \"Invalid Remita RRR validation data.\" };\n    }\n\n    // Remita API key is missing. Assuming it's also a subscription key.\n    const REMITA_SUBSCRIPTION_KEY = process.env.REMITA_SUBSCRIPTION_KEY;\n    if (!REMITA_SUBSCRIPTION_KEY) {\n      console.error(\"Remita subscription key is not set.\");\n      return { success: false, error: \"Payment gateway is not configured correctly.\" };\n    }\n    \n    const { rrr, channelId } = validatedFields.data;\n\n    const remitaUrl = `https://wema-alatdev-apimgt.azure-api.net/remita-payments/api/RemitaPayment/ValidateRrr/${rrr}/${channelId}`;\n\n    try {\n        const response = await fetch(remitaUrl, {\n            method: 'GET',\n            headers: {\n                'Cache-Control': 'no-cache',\n                'Ocp-Apim-Subscription-Key': REMITA_SUBSCRIPTION_KEY,\n            }\n        });\n\n        const responseText = await response.text();\n        console.log(\"Remita ValidateRrr response status:\", response.status);\n        console.log(\"Remita ValidateRrr response body:\", responseText);\n        \n        if (response.ok) {\n            return { success: true, message: \"Remita RRR validated successfully.\", data: JSON.parse(responseText) };\n        } else {\n            return { success: false, error: `Failed to validate Remita RRR: ${responseText}` };\n        }\n\n    } catch(error) {\n        console.error(\"Error calling Remita ValidateRrr API:\", error);\n        return { success: false, error: \"Could not connect to the Remita payment gateway to validate RRR.\" };\n    }\n}\n\n    "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1246, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/checkout/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {generateVoiceResponse as '40d4ef3f17cac6671f3ce0fae5b2a708376fff0fbf'} from 'ACTIONS_MODULE0'\nexport {generateSpeechAudio as '40f3233a4d6b07c47e7e48dcd2d0a4954be17da116'} from 'ACTIONS_MODULE1'\nexport {createRemitaPayment as '40787d5eefe2ffbad56c5588488ffbaa8469ecdd3d'} from 'ACTIONS_MODULE2'\nexport {createPaystackPayment as '40d9dfe3c3ae4688a09169e2db2103cf9aa3714af0'} from 'ACTIONS_MODULE2'\n"],"names":[],"mappings":";AAAA;AACA;AACA","debugId":null}},
    {"offset": {"line": 1313, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/checkout/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/checkout/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/checkout/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA6R,GAC1T,2DACA","debugId":null}},
    {"offset": {"line": 1327, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/checkout/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/checkout/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/checkout/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAyQ,GACtS,uCACA","debugId":null}},
    {"offset": {"line": 1341, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}